name: Codex Auto-merge

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - labeled
      - ready_for_review

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  automerge:
    if: ${{ contains(github.event.pull_request.labels.*.name, 'codex-automerge') }}
    runs-on: ubuntu-latest
    steps:
      - name: Wait for required checks
        id: wait
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            const ref = pr.head.sha;
            const timeoutMs = 60 * 60 * 1000; // 1 hour timeout
            const intervalMs = 15000;
            const start = Date.now();

            async function wait(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function fetchStatus() {
              const [statusResp, checksResp] = await Promise.all([
                github.rest.repos.getCombinedStatusForRef({ owner, repo, ref }),
                github.rest.checks.listForRef({ owner, repo, ref })
              ]);

              const statuses = statusResp.data.statuses || [];
              const checkRuns = checksResp.data.check_runs || [];

              const failedStatus = statuses.some(status => status.state === 'failure' || status.state === 'error');
              const failedChecks = checkRuns.some(run => {
                if (run.status !== 'completed') {
                  return false;
                }
                return ['failure', 'timed_out', 'cancelled', 'action_required', 'stale'].includes(run.conclusion);
              });

              const pendingStatus = statusResp.data.state === 'pending';
              const pendingChecks = checkRuns.some(run => run.status !== 'completed');

              return {
                failed: failedStatus || failedChecks,
                pending: pendingStatus || pendingChecks,
                summary: {
                  statusState: statusResp.data.state,
                  checkCount: checkRuns.length,
                }
              };
            }

            while (true) {
              const result = await fetchStatus();
              core.info(`Status: ${JSON.stringify(result.summary)}`);

              if (result.failed) {
                core.setFailed('ERR_AUTOMERGE_001 Checks did not pass for codex auto-merge.');
                return;
              }

              if (!result.pending) {
                break;
              }

              if (Date.now() - start > timeoutMs) {
                core.setFailed('ERR_AUTOMERGE_001 Timed out waiting for checks to complete.');
                return;
              }

              await wait(intervalMs);
            }

            core.info('All required checks succeeded for codex auto-merge.');
      - name: Merge pull request with squash
        if: ${{ success() }}
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pr.number,
                merge_method: 'squash'
              });
            } catch (error) {
              core.setFailed(`ERR_AUTOMERGE_001 Failed to merge pull request: ${error.message}`);
            }
